%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 24.1 and Fixed-Point Designer 24.1          %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
function [computerState, probFinal, probQubit0, probQubit1] = quantumComputer_twoQubit_fixpt(opName_0,theta_0...
    ,phi_0,lambda_0,opName_1,theta_1,phi_1,lambda_1,initState_0,initState_1)
    nt=numerictype(1,16,15);
    State_template_real = fi([],nt);
    State_template_imag = fi([],nt);
    State_template = complexx(State_template_real,State_template_imag);
    computerState = cast(zeros(4,1),'like',State_template);
    initState = two_qubit_register(initState_0,initState_1);

    op_0_0 = getOperator(opName_0(1,1),theta_0(1,1),phi_0(1,1),lambda_0(1,1));
    op_1_0 = getOperator(opName_0(2,1),theta_0(2,1),phi_0(2,1),lambda_0(2,1));
    op_2_0 = getOperator(opName_0(3,1),theta_0(3,1),phi_0(3,1),lambda_0(3,1));

    op_0_1 = getOperator(opName_1(1,1),theta_1(1,1),phi_1(1,1),lambda_1(1,1));
    
    op_1_1 = getOperator(opName_1(2,1),theta_1(2,1),phi_1(2,1),lambda_1(2,1));
    op_2_1 = getOperator(opName_1(3,1),theta_1(3,1),phi_1(1,1),lambda_1(3,1));

    if (opName_0(1,1) == fi(15,0,16,0))
        ControlQubit = fi(0,0,16,0);
        op_0 = getControledOperator(op_0_1,ControlQubit);
    else
        if (opName_1(1,1) == fi(15,0,16,0))
            ControlQubit = fi(1,0,16,0);
            op_0 = getControledOperator(op_0_0,ControlQubit);
        else
            op_0 = prodotto_di_kronecker(op_0_0,op_0_1);
        end
    end
    
    if (opName_0(2,1) == fi(15,0,16,0))
        ControlQubit = fi(0,0,16,0);
        op_1 = getControledOperator(op_1_1,ControlQubit);
    else
        if (opName_1(2,1) == fi(15,0,16,0))
            ControlQubit = fi(1,0,16,0);
            op_1 = getControledOperator(op_1_0,ControlQubit);
        else
            op_1 = prodotto_di_kronecker(op_1_0,op_1_1);
        end
    end

    if (opName_0(3,1) == fi(15,0,16,0))
        ControlQubit = fi(0,0,16,0);
        op_2 = getControledOperator(op_2_1,ControlQubit);
    else
        if (opName_1(3,1) == fi(15,0,16,0))
            ControlQubit = fi(1,0,16,0);
            op_2 = getControledOperator(op_2_0,ControlQubit);
        else
            op_2 = prodotto_di_kronecker(op_2_0,op_2_1);
        end
    end

    op_temp = matrix_complex_mults_s1(op_1,op_0);
    algMatrix = matrix_complex_mults_s2(op_2,op_temp);
    computerState(:) = Apply_Operator(algMatrix, initState);
    [fmo_1, fmo_2, fmo_3] = probFinal_twoQubit(computerState);
    probFinal = fmo_1;
    probQubit0 = fmo_2;
    probQubit1 = fmo_3;
end

function C = two_qubit_register(c1, c2)
    c_00 = c1(1, 1)*c2(1, 1);
    c_01 = c1(1, 1)*c2(2, 1);
    c_10 = c1(2, 1)*c2(1, 1);
    c_11 = c1(2, 1)*c2(2, 1);

    C = [c_00; c_01; c_01; c_11];
end

function op = getOperator(opName, theta, phi, lambda)
    fm = fimath('RoundingMethod','Nearest',...
            'OverflowAction','Saturate', ...
            'ProductMode','SpecifyPrecision', ...
            'ProductWordLength', 16, ...
            'ProductFractionLength', 15, ...
            'SumMode', 'SpecifyPrecision', ...
            'SumWordLength', 16, ...
            'SumFractionLength', 15, ...
            'CastBeforeSum', true);
    nt = numerictype(1, 16, 15);
    op_real = fi([], nt, fm);
    op_imag = fi([], nt, fm);
    op_template = complexx(op_real, op_imag);

    [fmo_1, fmo_2] = cordicsincos(phi, 15);
    seno_phi = fmo_1;
    coseno_phi = fmo_2;

    half_theta = bitsra(theta, 1);
    [fmo_3, fmo_4] = cordicsincos(half_theta, 15);
    seno_half_theta = fmo_3;
    coseno_half_theta = fmo_4;
    
    [fmo_5, fmo_6] = cordicsincos(theta, 15);
    seno_theta = fmo_5;
    coseno_theta = fmo_6;
    [fmo_7, fmo_8] = cordicsincos(lambda, 15);
    seno_lambda = fmo_7;
    coseno_lambda = fmo_8;

    op = cast([0; 0; 0; 0], 'like', op_template);

    if opName == fi(0,0,16,0)
        op(:) = [1 0; 0 1];
    elseif opName == fi(1,0,16,0)
        op(:) = [0 1; 1 0];
    elseif opName == fi(2,0,16,0)
        op(:) = [0 -1i; 1i 0];
    elseif opName == fi(3,0,16,0)
        op(:) = [1 0; 0 -1];
    elseif opName == fi(4,0,16,0)
        op(:) = 0.707106781186547*[1 1; 1 -1];
    elseif opName == fi(5,0,16,0)
        op(:) = [1 0; 0 1i];
    elseif opName == fi(6,0,16,0)
        op(:) = [1 0; 0 ...
            0.707106781186547+1i*0.707106781186547];
    elseif opName == fi(7,0,16,0)
        op(:) = [1 0; 0 -1i];
    elseif opName == fi(8,0,16,0)
        op(:) = [1 0; 0 ...
            0.707106781186547-1i*0.707106781186547];
    elseif opName == fi(9,0,16,0)
        op(:) = [1 0; 0 coseno_theta+1i*seno_theta];
    elseif opName == fi(10,0,16,0)
        op(:) = 0.707106781186547*[1  -(coseno_theta+1i*seno_theta); ...
            coseno_phi+1i*seno_phi  coseno_theta*coseno_phi-seno_theta...
            *seno_phi+1i*(seno_theta*coseno_phi+coseno_theta*seno_phi)];
    elseif opName == fi(11,0,16,0)
        op(:) = [coseno_half_theta  -(coseno_lambda*seno_half_theta+1i*(seno_lambda*seno_half_theta)); ...
            coseno_phi*seno_half_theta+1i*seno_phi*seno_half_theta  ...
            (coseno_lambda*coseno_phi-seno_lambda*seno_phi)*coseno_half_theta+1i*(seno_lambda*coseno_phi+...
            coseno_lambda*seno_phi)*coseno_half_theta];
    elseif opName == fi(12,0,16,0)
        op(:) = [coseno_half_theta -1i*seno_half_theta; -1i*seno_half_theta coseno_half_theta];
    elseif opName == fi(13,0,16,0)
        op(:) = [coseno_half_theta fi_uminus(seno_half_theta); seno_half_theta coseno_half_theta];
    elseif opName == fi(14,0,16,0)
        op(:) = [coseno_half_theta-1i*seno_half_theta 0; 0 coseno_half_theta+1i*seno_half_theta];
    else
        op(:) = [0 0; 0 0];
    end
end

function op = getControledOperator(baseOp, ControlQubit)
    fm = get_fimath();

    fm = fimath('RoundingMethod','Nearest',...
        'OverflowAction','Saturate',...
        'ProductMode','FullPrecision',...
        'SumMode','FullPrecision');
    nt = numerictype(1,16,15);

    op_real = fi([],nt,fm);
    op_imag = fi([],nt,fm);
    op_template = complexx(op_real,op_imag);
    op = cast(zeros(16,1),'like', op_template);

    baseOp_temp = reshape(baseOp,2,2);
        if ControlQubit == 0
            op(:) = [fi(eye(2), 0, 1, 0, fm) zeros(2); fi(zeros(2), 0, 1, 0, fm) baseOp_temp];
        elseif ControlQubit == 1
            op(:) = [fi(1, 0, 1, 0, fm) 0 0 0; 
                fi(0, 0, 1, 0, fm) baseOp_temp(1,1) 0 baseOp_temp(1,2);
                fi(0, 0, 1, 0, fm) 0 1 0; 
                fi(0, 0, 1, 0, fm) baseOp_temp(2,1) 0 baseOp_temp(2,2)];
        else
            op(:) = zeros(4);
        end
end

function C = prodotto_di_kronecker(c1, c2)
    fm = fimath('RoundingMethod','Nearest', 'OverflowAction','Saturate', 'ProductMode', 'FullPrecision', 'SumMode', 'FullPrecision');
    nt = numerictype(1, 16, 15);
    C_real = fi([], nt, fm);
    C_imag = fi([], nt, fm);
    C_template = complexx(C_real, C_imag);
    C = cast(zeros(16, 1), 'like', C_template);
    c1_temp = reshape(c1, 2, 2);
    c2_temp = reshape(c2, 2, 2);
    c_00 = c1_temp(1, 1)*c2_temp;
    c_01 = c1_temp(1, 2)*c2_temp;
    c_10 = c1_temp(2, 1)*c2_temp;
    c_11 = c1_temp(2, 2)*c2_temp;
    C_temp = [c_00 c_01; c_10 c_11];
    C(:) = C_temp(:);
end

function C = matrix_complex_mults_s1(A,B)
    A_temp = reshape(A,4,4);
    B_temp = reshape(B,4,4);
    C_temp = A_temp*B_temp;
    C = C_temp(:);
end

function C = matrix_complex_mults_s2(A,B)
    A_temp = reshape(A,4,4);
    B_temp = reshape(B,4,4);
    C_temp = A_temp*B_temp;
    C = C_temp(:);
end

function C = Apply_Operator(Operator, A)
    Operator_temp = reshape(Operator,4,4);
    A = reshape(A, 4, 1);
    C = Operator_temp*A;
end

function [probFinal,probQubit0,probQubit1] = probFinal_twoQubit(computerState)
    fm = fimath('RoundingMethod','Nearest',...
        'OverflowAction','Saturate',...
        'ProductMode','FullPrecision',...
        'SumMode','FullPrecision');
    nt = numerictype(0,16,16);
    prob = fi([0; 0; 0; 0], nt, fm);
    probFinal = fi([0; 0; 0; 0], nt, fm);
    probQubit0 = fi([0; 0], nt, fm);
    probQubit1 = fi([0; 0], nt, fm);
    abs_value = cordicabs(computerState,15);
    prob(:) = abs_value.*abs_value;
    probQubit0(:) = [prob(1,1)+prob(2,1);
                    prob(3,1)+prob(4,1)];

    probQubit1(:) = [prob(1,1)+prob(3,1);
                    prob(2,1)+prob(4,1)];
    probFinal(:) = prob;
end



function c = complexx(varargin)
    coder.inline( 'always' );
    if nargin==2
        re = varargin{ 1 };
        im = varargin{ 2 };
        if isfi( re ) && isfi( im )
            % Choose wider type
            NT = fixed.aggregateType( re, im );
            c = complex( fi( re, NT ), fi( im, NT ) );
        else
            c = complex( re, im );
        end
    elseif nargin==1
        c = complex( varargin{ 1 } );
    end
end


function y = fi_uminus(a)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = -fi( a, new_nt, fimath( a ) );
    else
        y = -a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
