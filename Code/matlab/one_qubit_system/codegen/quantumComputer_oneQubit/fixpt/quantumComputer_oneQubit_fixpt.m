%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 24.1 and Fixed-Point Designer 24.1          %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
function [computerState, probFinal] = quantumComputer_oneQubit_fixpt(opName,theta,phi,lambda,initState)
    nt = numerictype(1,16,15);
    template_real = fi([],nt);
    template_imag = fi([],nt);
    template = complexx(template_real,template_imag);
    computerState = cast([0;0], 'like', template);
    op_0 = getOperator(opName(1,1), theta(1,1), phi(1,1), lambda(1,1));
    op_1 = getOperator(opName(2,1), theta(2,1), phi(2,1), lambda(2,1));
    op_2 = getOperator(opName(3,1), theta(3,1), phi(3,1), lambda(3,1));
    op_temp = matrix_complex_mults(op_1,op_0);
    op = matrix_complex_mults(op_2,op_temp);
    computerState(:) = Apply_Operator(initState,op);
    probFinal = probFinal_oneQubit(computerState);
end

function op = getOperator(opName, theta, phi, lambda)
    fm = get_fimath();

    fm = fimath('RoundingMethod','Nearest',...
            'OverflowAction','Saturate', ...
            'ProductMode','SpecifyPrecision', ...
            'ProductWordLength', 16, ...
            'ProductFractionLength', 15, ...
            'SumMode', 'SpecifyPrecision', ...
            'SumWordLength', 16, ...
            'SumFractionLength', 15, ...
            'CastBeforeSum', true);
    nt = numerictype(1, 16, 15);
    op_real = fi([], nt, fm);
    op_imag = fi([], nt, fm);
    op_template = complexx(op_real, op_imag);

    [fmo_1, fmo_2] = cordicsincos(phi, fi(15, 0, 4, 0, fm));
    seno_phi = fmo_1;
    coseno_phi = fmo_2;

    half_theta = bitsra(theta, 1);
    [fmo_3, fmo_4] = cordicsincos(half_theta, fi(15, 0, 4, 0, fm));
    seno_half_theta = fmo_3;
    coseno_half_theta = fmo_4;
    [fmo_5, fmo_6] = cordicsincos(theta, fi(1, 0, 1, 0, fm));
    seno_theta = fmo_5;
    coseno_theta = fmo_6;
    [fmo_7, fmo_8] = cordicsincos(lambda, fi(15, 0, 4, 0, fm));
    seno_lambda = fmo_7;
    coseno_lambda = fmo_8;

    op = cast([0; 0; 0; 0], 'like', op_template);

    if opName == fi(0,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 1];
        %F2F: End block
    elseif opName == fi(1,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [0 1; 1 0];
        %F2F: End block
    elseif opName == fi(2,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [0 -1i; 1i 0];
        %F2F: End block
    elseif opName == fi(3,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 -1];
        %F2F: End block
    elseif opName == fi(4,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = 0.707106781186547*[1 1; 1 -1];
        %F2F: End block
    elseif opName == fi(5,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 1i];
        %F2F: End block
    elseif opName == fi(6,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 ...
            0.707106781186547+1i*0.707106781186547];
        %F2F: End block
    elseif opName == fi(7,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 -1i];
        %F2F: End block
    elseif opName == fi(8,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0; 0 ...
            0.707106781186547-1i*0.707106781186547];
        %F2F: End block
    elseif opName == fi(9,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [fi(1, 0, 1, 0, fm) 0; fi(0, 0, 1, 0, fm) coseno_theta+fi(1i, 0, 1, 0, fm)*seno_theta];
        %F2F: End block
    elseif opName == fi(10,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = fi(0.707106781186547, 0, 14, 14, fm)*[fi(1, 0, 1, 0, fm)  fi_signed(fi_uminus(coseno_theta))-fi(1i, 0, 1, 0, fm)*seno_theta; ...
            coseno_phi+fi(1i, 0, 1, 0, fm)*seno_phi  fi_signed(coseno_theta*coseno_phi)-seno_theta...
            *seno_phi+fi(1i, 0, 1, 0, fm)*(seno_theta*coseno_phi+coseno_theta*seno_phi)];
        %F2F: End block
    elseif opName == fi(11,0,16,0)
        op(:) = [fi(coseno_half_theta, 1, 14, 13, fm)  fi_uminus((coseno_lambda*seno_half_theta + fi(1i, 0, 1, 0, fm)*(seno_lambda*seno_half_theta))); ...
            fi(coseno_phi*seno_half_theta+fi(1i, 0, 1, 0, fm)*seno_phi*seno_half_theta, 1, 14, 13, fm) ...
            (fi_signed(coseno_lambda*coseno_phi)-seno_lambda*seno_phi)*coseno_half_theta+fi(1i, 0, 1, 0, fm)*(seno_lambda*coseno_phi+...
            coseno_lambda*seno_phi)*coseno_half_theta];
    elseif opName == fi(12,0,16,0)
        op(:) = [fi(coseno_half_theta, 1, 14, 13, fm) fi(-1i, 1, 2, 0, fm)*seno_half_theta; fi(fi(-1i, 1, 2, 0, fm)*seno_half_theta, 1, 14, 13, fm) coseno_half_theta];
    elseif opName == fi(13,0,16,0)
        op(:) = [fi(coseno_half_theta, 1, 14, 13, fm) seno_half_theta; fi(seno_half_theta, 1, 14, 13, fm) coseno_half_theta];
    elseif opName == fi(14,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [fi(fi_signed(coseno_half_theta)-fi(1i, 0, 1, 0, fm)*seno_half_theta, 0, 1, 0, fm) 0; fi(0, 0, 1, 0, fm) coseno_half_theta+fi(1i, 0, 1, 0, fm)*seno_half_theta];
        %F2F: End block
    elseif opName == fi(15,0,16,0)
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [1 0;0 1];
        %F2F: End block
    else
        %F2F: No information found for converting the following block of code
        %F2F: Start block
        op(:) = [0 0; 0 0];
        %F2F: End block
    end
end

function C = matrix_complex_mults(A,B)
    A_temp = reshape(A,2,2);
    B_temp = reshape(B,2,2);
    C_temp = A_temp*B_temp;
    C = C_temp(:);
end

function C = Apply_Operator(A,Operator)
    Operator_temp = reshape(Operator,2,2);
    C = Operator_temp*A;
end

function probFinal = probFinal_oneQubit(a)
    fm = get_fimath();

    fm = fimath('RoundingMethod','Nearest',...
            'OverflowAction','Saturate', ...
            'ProductMode','SpecifyPrecision', ...
            'ProductWordLength', 16, ...
            'ProductFractionLength', 15, ...
            'SumMode', 'SpecifyPrecision', ...
            'SumWordLength', 16, ...
            'SumFractionLength', 15, ...
            'CastBeforeSum', true);
    nt = numerictype(0,16,16);
    probFinal = fi([0;0],nt,fm);
    abs_value = cordicabs(a,fi(15, 0, 4, 0, fm));
    probFinal(:) = abs_value.*abs_value;
end



function c = complexx(varargin)
    coder.inline( 'always' );
    if nargin==2
        re = varargin{ 1 };
        im = varargin{ 2 };
        if isfi( re ) && isfi( im )
            % Choose wider type
            NT = fixed.aggregateType( re, im );
            c = complex( fi( re, NT ), fi( im, NT ) );
        else
            c = complex( re, im );
        end
    elseif nargin==1
        c = complex( varargin{ 1 } );
    end
end


function y = fi_signed(a)
    coder.inline( 'always' );
    if isfi( a ) && ~(issigned( a ))
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = fi( a, new_nt, fimath( a ) );
    else
        y = a;
    end
end


function y = fi_uminus(a)
    coder.inline( 'always' );
    if isfi( a )
        nt = numerictype( a );
        new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
        y = -fi( a, new_nt, fimath( a ) );
    else
        y = -a;
    end
end

function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'MaxProductWordLength', 128,...
	     'SumMode','FullPrecision',...
	     'MaxSumWordLength', 128);
end
