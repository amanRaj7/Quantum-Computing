// -------------------------------------------------------------
// 
// File Name: C:\Doc\github\Quantum\Code\matlab\two_qubit_system\codegen\quantumComputer_twoQubit\hdlsrc\quantumComputer_twoQubit_fixpt_tb.v
// Created: 2025-03-31 15:51:28
// 
// Generated by MATLAB 24.1, MATLAB Coder 24.1 and HDL Coder 24.1
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: quantumComputer_twoQubit_fixpt_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module quantumComputer_twoQubit_fixpt_tb;



  reg  clk;
  reg  reset;
  wire enb;
  wire computerState_re_0_addr;  // ufix1
  wire computerState_re_0_lastAddr;  // ufix1
  wire probFinal_0_addr;  // ufix1
  wire probFinal_0_lastAddr;  // ufix1
  wire probQubit0_0_addr;  // ufix1
  wire probQubit0_0_lastAddr;  // ufix1
  wire probQubit1_0_addr;  // ufix1
  wire probQubit1_0_lastAddr;  // ufix1
  wire probQubit1_0_done;  // ufix1
  wire rdEnb;
  wire probQubit1_0_done_enb;  // ufix1
  wire resetn;
  reg  check4_done;  // ufix1
  wire probQubit0_0_done;  // ufix1
  wire probQubit0_0_done_enb;  // ufix1
  reg  check3_done;  // ufix1
  wire probFinal_0_done;  // ufix1
  wire probFinal_0_done_enb;  // ufix1
  reg  check2_done;  // ufix1
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire computerState_re_0_done;  // ufix1
  wire computerState_re_0_done_enb;  // ufix1
  reg  check1_done;  // ufix1
  wire ce_out;
  wire [15:0] rawData_opName_0_0;  // uint16
  reg [15:0] holdData_opName_0_0;  // uint16
  wire [15:0] rawData_opName_0_1;  // uint16
  reg [15:0] holdData_opName_0_1;  // uint16
  wire [15:0] rawData_opName_0_2;  // uint16
  reg [15:0] holdData_opName_0_2;  // uint16
  wire signed [15:0] rawData_theta_0_0;  // sfix16_En13
  reg signed [15:0] holdData_theta_0_0;  // sfix16_En13
  wire signed [15:0] rawData_theta_0_1;  // sfix16_En13
  reg signed [15:0] holdData_theta_0_1;  // sfix16_En13
  wire signed [15:0] rawData_theta_0_2;  // sfix16_En13
  reg signed [15:0] holdData_theta_0_2;  // sfix16_En13
  wire signed [15:0] rawData_phi_0_0;  // sfix16_En13
  reg signed [15:0] holdData_phi_0_0;  // sfix16_En13
  wire signed [15:0] rawData_phi_0_1;  // sfix16_En13
  reg signed [15:0] holdData_phi_0_1;  // sfix16_En13
  wire signed [15:0] rawData_phi_0_2;  // sfix16_En13
  reg signed [15:0] holdData_phi_0_2;  // sfix16_En13
  wire signed [15:0] rawData_lambda_0_0;  // sfix16_En13
  reg signed [15:0] holdData_lambda_0_0;  // sfix16_En13
  wire signed [15:0] rawData_lambda_0_1;  // sfix16_En13
  reg signed [15:0] holdData_lambda_0_1;  // sfix16_En13
  wire signed [15:0] rawData_lambda_0_2;  // sfix16_En13
  reg signed [15:0] holdData_lambda_0_2;  // sfix16_En13
  wire [15:0] rawData_opName_1_0;  // uint16
  reg [15:0] holdData_opName_1_0;  // uint16
  wire [15:0] rawData_opName_1_1;  // uint16
  reg [15:0] holdData_opName_1_1;  // uint16
  wire [15:0] rawData_opName_1_2;  // uint16
  reg [15:0] holdData_opName_1_2;  // uint16
  wire signed [15:0] rawData_theta_1_0;  // sfix16_En13
  reg signed [15:0] holdData_theta_1_0;  // sfix16_En13
  wire signed [15:0] rawData_theta_1_1;  // sfix16_En13
  reg signed [15:0] holdData_theta_1_1;  // sfix16_En13
  wire signed [15:0] rawData_theta_1_2;  // sfix16_En13
  reg signed [15:0] holdData_theta_1_2;  // sfix16_En13
  wire signed [15:0] rawData_phi_1_0;  // sfix16_En13
  reg signed [15:0] holdData_phi_1_0;  // sfix16_En13
  wire signed [15:0] rawData_phi_1_1;  // sfix16_En13
  reg signed [15:0] holdData_phi_1_1;  // sfix16_En13
  wire signed [15:0] rawData_phi_1_2;  // sfix16_En13
  reg signed [15:0] holdData_phi_1_2;  // sfix16_En13
  wire signed [15:0] rawData_lambda_1_0;  // sfix16_En13
  reg signed [15:0] holdData_lambda_1_0;  // sfix16_En13
  wire signed [15:0] rawData_lambda_1_1;  // sfix16_En13
  reg signed [15:0] holdData_lambda_1_1;  // sfix16_En13
  wire signed [15:0] rawData_lambda_1_2;  // sfix16_En13
  reg signed [15:0] holdData_lambda_1_2;  // sfix16_En13
  wire signed [15:0] rawData_initState_0_re_0;  // sfix16_En15
  reg signed [15:0] holdData_initState_0_re_0;  // sfix16_En15
  wire signed [15:0] rawData_initState_0_re_1;  // sfix16_En15
  reg signed [15:0] holdData_initState_0_re_1;  // sfix16_En15
  wire signed [15:0] rawData_initState_0_im_0;  // sfix16_En15
  reg signed [15:0] holdData_initState_0_im_0;  // sfix16_En15
  wire signed [15:0] rawData_initState_0_im_1;  // sfix16_En15
  reg signed [15:0] holdData_initState_0_im_1;  // sfix16_En15
  wire signed [15:0] rawData_initState_1_re_0;  // sfix16_En15
  reg signed [15:0] holdData_initState_1_re_0;  // sfix16_En15
  wire signed [15:0] rawData_initState_1_re_1;  // sfix16_En15
  reg signed [15:0] holdData_initState_1_re_1;  // sfix16_En15
  wire signed [15:0] rawData_initState_1_im_0;  // sfix16_En15
  reg signed [15:0] holdData_initState_1_im_0;  // sfix16_En15
  wire signed [15:0] rawData_initState_1_im_1;  // sfix16_En15
  reg signed [15:0] holdData_initState_1_im_1;  // sfix16_En15
  reg [15:0] opName_0_0_offset;  // uint16
  wire [15:0] opName_0_0_1;  // uint16
  reg [15:0] opName_0_1_offset;  // uint16
  wire [15:0] opName_0_1_1;  // uint16
  reg [15:0] opName_0_2_offset;  // uint16
  wire [15:0] opName_0_2_1;  // uint16
  reg signed [15:0] theta_0_0_offset;  // sfix16_En13
  wire signed [15:0] theta_0_0_1;  // sfix16_En13
  reg signed [15:0] theta_0_1_offset;  // sfix16_En13
  wire signed [15:0] theta_0_1_1;  // sfix16_En13
  reg signed [15:0] theta_0_2_offset;  // sfix16_En13
  wire signed [15:0] theta_0_2_1;  // sfix16_En13
  reg signed [15:0] phi_0_0_offset;  // sfix16_En13
  wire signed [15:0] phi_0_0_1;  // sfix16_En13
  reg signed [15:0] phi_0_1_offset;  // sfix16_En13
  wire signed [15:0] phi_0_1_1;  // sfix16_En13
  reg signed [15:0] phi_0_2_offset;  // sfix16_En13
  wire signed [15:0] phi_0_2_1;  // sfix16_En13
  reg signed [15:0] lambda_0_0_offset;  // sfix16_En13
  wire signed [15:0] lambda_0_0_1;  // sfix16_En13
  reg signed [15:0] lambda_0_1_offset;  // sfix16_En13
  wire signed [15:0] lambda_0_1_1;  // sfix16_En13
  reg signed [15:0] lambda_0_2_offset;  // sfix16_En13
  wire signed [15:0] lambda_0_2_1;  // sfix16_En13
  reg [15:0] opName_1_0_offset;  // uint16
  wire [15:0] opName_1_0_1;  // uint16
  reg [15:0] opName_1_1_offset;  // uint16
  wire [15:0] opName_1_1_1;  // uint16
  reg [15:0] opName_1_2_offset;  // uint16
  wire [15:0] opName_1_2_1;  // uint16
  reg signed [15:0] theta_1_0_offset;  // sfix16_En13
  wire signed [15:0] theta_1_0_1;  // sfix16_En13
  reg signed [15:0] theta_1_1_offset;  // sfix16_En13
  wire signed [15:0] theta_1_1_1;  // sfix16_En13
  reg signed [15:0] theta_1_2_offset;  // sfix16_En13
  wire signed [15:0] theta_1_2_1;  // sfix16_En13
  reg signed [15:0] phi_1_0_offset;  // sfix16_En13
  wire signed [15:0] phi_1_0_1;  // sfix16_En13
  reg signed [15:0] phi_1_1_offset;  // sfix16_En13
  wire signed [15:0] phi_1_1_1;  // sfix16_En13
  reg signed [15:0] phi_1_2_offset;  // sfix16_En13
  wire signed [15:0] phi_1_2_1;  // sfix16_En13
  reg signed [15:0] lambda_1_0_offset;  // sfix16_En13
  wire signed [15:0] lambda_1_0_1;  // sfix16_En13
  reg signed [15:0] lambda_1_1_offset;  // sfix16_En13
  wire signed [15:0] lambda_1_1_1;  // sfix16_En13
  reg signed [15:0] lambda_1_2_offset;  // sfix16_En13
  wire signed [15:0] lambda_1_2_1;  // sfix16_En13
  reg signed [15:0] initState_0_re_0_offset;  // sfix16_En15
  wire signed [15:0] initState_0_re_0_1;  // sfix16_En15
  reg signed [15:0] initState_0_re_1_offset;  // sfix16_En15
  wire signed [15:0] initState_0_re_1_1;  // sfix16_En15
  reg signed [15:0] initState_0_im_0_offset;  // sfix16_En15
  wire signed [15:0] initState_0_im_0_1;  // sfix16_En15
  reg signed [15:0] initState_0_im_1_offset;  // sfix16_En15
  wire signed [15:0] initState_0_im_1_1;  // sfix16_En15
  reg signed [15:0] initState_1_re_0_offset;  // sfix16_En15
  wire signed [15:0] initState_1_re_0_1;  // sfix16_En15
  reg signed [15:0] initState_1_re_1_offset;  // sfix16_En15
  wire signed [15:0] initState_1_re_1_1;  // sfix16_En15
  reg signed [15:0] initState_1_im_0_offset;  // sfix16_En15
  wire signed [15:0] initState_1_im_0_1;  // sfix16_En15
  reg signed [15:0] initState_1_im_1_offset;  // sfix16_En15
  wire signed [15:0] initState_1_im_1_1;  // sfix16_En15
  wire signed [15:0] computerState_re_0;  // sfix16_En15
  wire signed [15:0] computerState_re_1;  // sfix16_En15
  wire signed [15:0] computerState_re_2;  // sfix16_En15
  wire signed [15:0] computerState_re_3;  // sfix16_En15
  wire signed [15:0] computerState_im_0;  // sfix16_En15
  wire signed [15:0] computerState_im_1;  // sfix16_En15
  wire signed [15:0] computerState_im_2;  // sfix16_En15
  wire signed [15:0] computerState_im_3;  // sfix16_En15
  wire [15:0] probFinal_0;  // ufix16_En16
  wire [15:0] probFinal_1;  // ufix16_En16
  wire [15:0] probFinal_2;  // ufix16_En16
  wire [15:0] probFinal_3;  // ufix16_En16
  wire [15:0] probQubit0_0;  // ufix16_En16
  wire [15:0] probQubit0_1;  // ufix16_En16
  wire [15:0] probQubit1_0;  // ufix16_En16
  wire [15:0] probQubit1_1;  // ufix16_En16
  wire signed [15:0] computerState_re_0_re_0_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_re_0_ref;  // sfix16_En15
  reg  computerState_re_0_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_re_1_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_re_1_ref;  // sfix16_En15
  reg  computerState_re_1_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_re_2_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_re_2_ref;  // sfix16_En15
  reg  computerState_re_2_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_re_3_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_re_3_ref;  // sfix16_En15
  reg  computerState_re_3_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_im_0_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_im_0_ref;  // sfix16_En15
  reg  computerState_im_0_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_im_1_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_im_1_ref;  // sfix16_En15
  reg  computerState_im_1_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_im_2_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_im_2_ref;  // sfix16_En15
  reg  computerState_im_2_testFailure;  // ufix1
  wire signed [15:0] computerState_re_0_im_3_expected_1;  // sfix16_En15
  wire signed [15:0] computerState_im_3_ref;  // sfix16_En15
  reg  computerState_im_3_testFailure;  // ufix1
  wire [15:0] probFinal_0_0_expected_1;  // ufix16_En16
  wire [15:0] probFinal_0_ref;  // ufix16_En16
  reg  probFinal_0_testFailure;  // ufix1
  wire [15:0] probFinal_0_1_expected_1;  // ufix16_En16
  wire [15:0] probFinal_1_ref;  // ufix16_En16
  reg  probFinal_1_testFailure;  // ufix1
  wire [15:0] probFinal_0_2_expected_1;  // ufix16_En16
  wire [15:0] probFinal_2_ref;  // ufix16_En16
  reg  probFinal_2_testFailure;  // ufix1
  wire [15:0] probFinal_0_3_expected_1;  // ufix16_En16
  wire [15:0] probFinal_3_ref;  // ufix16_En16
  reg  probFinal_3_testFailure;  // ufix1
  wire [15:0] probQubit0_0_0_expected_1;  // ufix16_En16
  wire [15:0] probQubit0_0_ref;  // ufix16_En16
  reg  probQubit0_0_testFailure;  // ufix1
  wire [15:0] probQubit0_0_1_expected_1;  // ufix16_En16
  wire [15:0] probQubit0_1_ref;  // ufix16_En16
  reg  probQubit0_1_testFailure;  // ufix1
  wire [15:0] probQubit1_0_0_expected_1;  // ufix16_En16
  wire [15:0] probQubit1_0_ref;  // ufix16_En16
  reg  probQubit1_0_testFailure;  // ufix1
  wire [15:0] probQubit1_0_1_expected_1;  // ufix16_En16
  wire [15:0] probQubit1_1_ref;  // ufix16_En16
  reg  probQubit1_1_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign computerState_re_0_lastAddr = 1'b1;



  assign probFinal_0_lastAddr = 1'b1;



  assign probQubit0_0_lastAddr = 1'b1;



  assign probQubit1_0_lastAddr = 1'b1;



  assign probQubit1_0_done_enb = probQubit1_0_done & rdEnb;



  assign probQubit1_0_done = probQubit1_0_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_4
      if (reset) begin
        check4_done <= 0;
      end
      else begin
        if (probQubit1_0_done_enb) begin
          check4_done <= probQubit1_0_done;
        end
      end
    end

  assign probQubit0_0_done_enb = probQubit0_0_done & rdEnb;



  assign probQubit0_0_done = probQubit0_0_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_3
      if (reset) begin
        check3_done <= 0;
      end
      else begin
        if (probQubit0_0_done_enb) begin
          check3_done <= probQubit0_0_done;
        end
      end
    end

  assign probFinal_0_done_enb = probFinal_0_done & rdEnb;



  assign probFinal_0_done = probFinal_0_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_2
      if (reset) begin
        check2_done <= 0;
      end
      else begin
        if (probFinal_0_done_enb) begin
          check2_done <= probFinal_0_done;
        end
      end
    end

  assign snkDonen =  ~ snkDone;



  assign tb_enb = resetn & snkDonen;



  assign rdEnb = (snkDone == 1'b0 ? tb_enb :
              1'b0);



  assign computerState_re_0_done_enb = computerState_re_0_done & rdEnb;



  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  initial
    begin : reset_gen
      reset <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset <= 1'b0;
    end

  assign resetn =  ~ reset;



  assign computerState_re_0_done = computerState_re_0_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_1
      if (reset) begin
        check1_done <= 0;
      end
      else begin
        if (computerState_re_0_done_enb) begin
          check1_done <= computerState_re_0_done;
        end
      end
    end

  assign snkDone = check4_done & (check3_done & (check1_done & check2_done));



  assign #2 enb = rdEnb;

  assign ce_out = enb & (rdEnb & tb_enb);



  // Data source for opName_0_0
  assign rawData_opName_0_0 = 16'b0000000000000011;



  // holdData reg for opName_0
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_0
      if (reset) begin
        holdData_opName_0_0 <= 16'bx;
      end
      else begin
        holdData_opName_0_0 <= rawData_opName_0_0;
      end
    end

  // Data source for opName_0_1
  assign rawData_opName_0_1 = 16'b0000000000001100;



  // holdData reg for opName_0
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_0_1
      if (reset) begin
        holdData_opName_0_1 <= 16'bx;
      end
      else begin
        holdData_opName_0_1 <= rawData_opName_0_1;
      end
    end

  // Data source for opName_0_2
  assign rawData_opName_0_2 = 16'b0000000000001111;



  // holdData reg for opName_0
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_0_2
      if (reset) begin
        holdData_opName_0_2 <= 16'bx;
      end
      else begin
        holdData_opName_0_2 <= rawData_opName_0_2;
      end
    end

  // Data source for theta_0_0
  assign rawData_theta_0_0 = 16'sb0000000000000000;



  // holdData reg for theta_0
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_0
      if (reset) begin
        holdData_theta_0_0 <= 16'bx;
      end
      else begin
        holdData_theta_0_0 <= rawData_theta_0_0;
      end
    end

  // Data source for theta_0_1
  assign rawData_theta_0_1 = 16'sb0001100100100010;



  // holdData reg for theta_0
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_0_1
      if (reset) begin
        holdData_theta_0_1 <= 16'bx;
      end
      else begin
        holdData_theta_0_1 <= rawData_theta_0_1;
      end
    end

  // Data source for theta_0_2
  assign rawData_theta_0_2 = 16'sb0000000000000000;



  // holdData reg for theta_0
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_0_2
      if (reset) begin
        holdData_theta_0_2 <= 16'bx;
      end
      else begin
        holdData_theta_0_2 <= rawData_theta_0_2;
      end
    end

  // Data source for phi_0_0
  assign rawData_phi_0_0 = 16'sb0000000000000000;



  // holdData reg for phi_0
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_0
      if (reset) begin
        holdData_phi_0_0 <= 16'bx;
      end
      else begin
        holdData_phi_0_0 <= rawData_phi_0_0;
      end
    end

  // Data source for phi_0_1
  assign rawData_phi_0_1 = 16'sb0000000000000000;



  // holdData reg for phi_0
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_0_1
      if (reset) begin
        holdData_phi_0_1 <= 16'bx;
      end
      else begin
        holdData_phi_0_1 <= rawData_phi_0_1;
      end
    end

  // Data source for phi_0_2
  assign rawData_phi_0_2 = 16'sb0000000000000000;



  // holdData reg for phi_0
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_0_2
      if (reset) begin
        holdData_phi_0_2 <= 16'bx;
      end
      else begin
        holdData_phi_0_2 <= rawData_phi_0_2;
      end
    end

  // Data source for lambda_0_0
  assign rawData_lambda_0_0 = 16'sb0000000000000000;



  // holdData reg for lambda_0
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_0
      if (reset) begin
        holdData_lambda_0_0 <= 16'bx;
      end
      else begin
        holdData_lambda_0_0 <= rawData_lambda_0_0;
      end
    end

  // Data source for lambda_0_1
  assign rawData_lambda_0_1 = 16'sb0000000000000000;



  // holdData reg for lambda_0
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_0_1
      if (reset) begin
        holdData_lambda_0_1 <= 16'bx;
      end
      else begin
        holdData_lambda_0_1 <= rawData_lambda_0_1;
      end
    end

  // Data source for lambda_0_2
  assign rawData_lambda_0_2 = 16'sb0000000000000000;



  // holdData reg for lambda_0
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_0_2
      if (reset) begin
        holdData_lambda_0_2 <= 16'bx;
      end
      else begin
        holdData_lambda_0_2 <= rawData_lambda_0_2;
      end
    end

  // Data source for opName_1_0
  assign rawData_opName_1_0 = 16'b0000000000001101;



  // holdData reg for opName_1
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_1
      if (reset) begin
        holdData_opName_1_0 <= 16'bx;
      end
      else begin
        holdData_opName_1_0 <= rawData_opName_1_0;
      end
    end

  // Data source for opName_1_1
  assign rawData_opName_1_1 = 16'b0000000000001100;



  // holdData reg for opName_1
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_1_1
      if (reset) begin
        holdData_opName_1_1 <= 16'bx;
      end
      else begin
        holdData_opName_1_1 <= rawData_opName_1_1;
      end
    end

  // Data source for opName_1_2
  assign rawData_opName_1_2 = 16'b0000000000001011;



  // holdData reg for opName_1
  always @(posedge clk or posedge reset)
    begin : stimuli_opName_1_2
      if (reset) begin
        holdData_opName_1_2 <= 16'bx;
      end
      else begin
        holdData_opName_1_2 <= rawData_opName_1_2;
      end
    end

  // Data source for theta_1_0
  assign rawData_theta_1_0 = 16'sb1100110110111100;



  // holdData reg for theta_1
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_1
      if (reset) begin
        holdData_theta_1_0 <= 16'bx;
      end
      else begin
        holdData_theta_1_0 <= rawData_theta_1_0;
      end
    end

  // Data source for theta_1_1
  assign rawData_theta_1_1 = 16'sb0001100100100010;



  // holdData reg for theta_1
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_1_1
      if (reset) begin
        holdData_theta_1_1 <= 16'bx;
      end
      else begin
        holdData_theta_1_1 <= rawData_theta_1_1;
      end
    end

  // Data source for theta_1_2
  assign rawData_theta_1_2 = 16'sb0001000011000001;



  // holdData reg for theta_1
  always @(posedge clk or posedge reset)
    begin : stimuli_theta_1_2
      if (reset) begin
        holdData_theta_1_2 <= 16'bx;
      end
      else begin
        holdData_theta_1_2 <= rawData_theta_1_2;
      end
    end

  // Data source for phi_1_0
  assign rawData_phi_1_0 = 16'sb0000000000000000;



  // holdData reg for phi_1
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_1
      if (reset) begin
        holdData_phi_1_0 <= 16'bx;
      end
      else begin
        holdData_phi_1_0 <= rawData_phi_1_0;
      end
    end

  // Data source for phi_1_1
  assign rawData_phi_1_1 = 16'sb0000000000000000;



  // holdData reg for phi_1
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_1_1
      if (reset) begin
        holdData_phi_1_1 <= 16'bx;
      end
      else begin
        holdData_phi_1_1 <= rawData_phi_1_1;
      end
    end

  // Data source for phi_1_2
  assign rawData_phi_1_2 = 16'sb1100110110111100;



  // holdData reg for phi_1
  always @(posedge clk or posedge reset)
    begin : stimuli_phi_1_2
      if (reset) begin
        holdData_phi_1_2 <= 16'bx;
      end
      else begin
        holdData_phi_1_2 <= rawData_phi_1_2;
      end
    end

  // Data source for lambda_1_0
  assign rawData_lambda_1_0 = 16'sb0000000000000000;



  // holdData reg for lambda_1
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_1
      if (reset) begin
        holdData_lambda_1_0 <= 16'bx;
      end
      else begin
        holdData_lambda_1_0 <= rawData_lambda_1_0;
      end
    end

  // Data source for lambda_1_1
  assign rawData_lambda_1_1 = 16'sb0000000000000000;



  // holdData reg for lambda_1
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_1_1
      if (reset) begin
        holdData_lambda_1_1 <= 16'bx;
      end
      else begin
        holdData_lambda_1_1 <= rawData_lambda_1_1;
      end
    end

  // Data source for lambda_1_2
  assign rawData_lambda_1_2 = 16'sb1111010011010100;



  // holdData reg for lambda_1
  always @(posedge clk or posedge reset)
    begin : stimuli_lambda_1_2
      if (reset) begin
        holdData_lambda_1_2 <= 16'bx;
      end
      else begin
        holdData_lambda_1_2 <= rawData_lambda_1_2;
      end
    end

  // Data source for initState_0_re_0
  assign rawData_initState_0_re_0 = 16'sb0110001011101011;



  // holdData reg for initState_0
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_0
      if (reset) begin
        holdData_initState_0_re_0 <= 16'bx;
      end
      else begin
        holdData_initState_0_re_0 <= rawData_initState_0_re_0;
      end
    end

  // Data source for initState_0_re_1
  assign rawData_initState_0_re_1 = 16'sb0101000011011011;



  // holdData reg for initState_0
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_0_1
      if (reset) begin
        holdData_initState_0_re_1 <= 16'bx;
      end
      else begin
        holdData_initState_0_re_1 <= rawData_initState_0_re_1;
      end
    end

  // Data source for initState_0_im_0
  assign rawData_initState_0_im_0 = 16'sb0000011011000100;



  // holdData reg for initState_0
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_0_2
      if (reset) begin
        holdData_initState_0_im_0 <= 16'bx;
      end
      else begin
        holdData_initState_0_im_0 <= rawData_initState_0_im_0;
      end
    end

  // Data source for initState_0_im_1
  assign rawData_initState_0_im_1 = 16'sb0000010000001001;



  // holdData reg for initState_0
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_0_3
      if (reset) begin
        holdData_initState_0_im_1 <= 16'bx;
      end
      else begin
        holdData_initState_0_im_1 <= rawData_initState_0_im_1;
      end
    end

  // Data source for initState_1_re_0
  assign rawData_initState_1_re_0 = 16'sb0110001011101011;



  // holdData reg for initState_1
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_1
      if (reset) begin
        holdData_initState_1_re_0 <= 16'bx;
      end
      else begin
        holdData_initState_1_re_0 <= rawData_initState_1_re_0;
      end
    end

  // Data source for initState_1_re_1
  assign rawData_initState_1_re_1 = 16'sb0101000011011011;



  // holdData reg for initState_1
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_1_1
      if (reset) begin
        holdData_initState_1_re_1 <= 16'bx;
      end
      else begin
        holdData_initState_1_re_1 <= rawData_initState_1_re_1;
      end
    end

  // Data source for initState_1_im_0
  assign rawData_initState_1_im_0 = 16'sb0000011011000100;



  // holdData reg for initState_1
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_1_2
      if (reset) begin
        holdData_initState_1_im_0 <= 16'bx;
      end
      else begin
        holdData_initState_1_im_0 <= rawData_initState_1_im_0;
      end
    end

  // Data source for initState_1_im_1
  assign rawData_initState_1_im_1 = 16'sb0000010000001001;



  // holdData reg for initState_1
  always @(posedge clk or posedge reset)
    begin : stimuli_initState_1_3
      if (reset) begin
        holdData_initState_1_im_1 <= 16'bx;
      end
      else begin
        holdData_initState_1_im_1 <= rawData_initState_1_im_1;
      end
    end

  always @(rawData_opName_0_0 or rdEnb)
    begin : stimuli_opName_0_3
      if (rdEnb == 1'b0) begin
        opName_0_0_offset <= holdData_opName_0_0;
      end
      else begin
        opName_0_0_offset <= rawData_opName_0_0;
      end
    end

  assign #2 opName_0_0_1 = opName_0_0_offset;

  always @(rawData_opName_0_1 or rdEnb)
    begin : stimuli_opName_0_4
      if (rdEnb == 1'b0) begin
        opName_0_1_offset <= holdData_opName_0_1;
      end
      else begin
        opName_0_1_offset <= rawData_opName_0_1;
      end
    end

  assign #2 opName_0_1_1 = opName_0_1_offset;

  always @(rawData_opName_0_2 or rdEnb)
    begin : stimuli_opName_0_5
      if (rdEnb == 1'b0) begin
        opName_0_2_offset <= holdData_opName_0_2;
      end
      else begin
        opName_0_2_offset <= rawData_opName_0_2;
      end
    end

  assign #2 opName_0_2_1 = opName_0_2_offset;

  always @(rawData_theta_0_0 or rdEnb)
    begin : stimuli_theta_0_3
      if (rdEnb == 1'b0) begin
        theta_0_0_offset <= holdData_theta_0_0;
      end
      else begin
        theta_0_0_offset <= rawData_theta_0_0;
      end
    end

  assign #2 theta_0_0_1 = theta_0_0_offset;

  always @(rawData_theta_0_1 or rdEnb)
    begin : stimuli_theta_0_4
      if (rdEnb == 1'b0) begin
        theta_0_1_offset <= holdData_theta_0_1;
      end
      else begin
        theta_0_1_offset <= rawData_theta_0_1;
      end
    end

  assign #2 theta_0_1_1 = theta_0_1_offset;

  always @(rawData_theta_0_2 or rdEnb)
    begin : stimuli_theta_0_5
      if (rdEnb == 1'b0) begin
        theta_0_2_offset <= holdData_theta_0_2;
      end
      else begin
        theta_0_2_offset <= rawData_theta_0_2;
      end
    end

  assign #2 theta_0_2_1 = theta_0_2_offset;

  always @(rawData_phi_0_0 or rdEnb)
    begin : stimuli_phi_0_3
      if (rdEnb == 1'b0) begin
        phi_0_0_offset <= holdData_phi_0_0;
      end
      else begin
        phi_0_0_offset <= rawData_phi_0_0;
      end
    end

  assign #2 phi_0_0_1 = phi_0_0_offset;

  always @(rawData_phi_0_1 or rdEnb)
    begin : stimuli_phi_0_4
      if (rdEnb == 1'b0) begin
        phi_0_1_offset <= holdData_phi_0_1;
      end
      else begin
        phi_0_1_offset <= rawData_phi_0_1;
      end
    end

  assign #2 phi_0_1_1 = phi_0_1_offset;

  always @(rawData_phi_0_2 or rdEnb)
    begin : stimuli_phi_0_5
      if (rdEnb == 1'b0) begin
        phi_0_2_offset <= holdData_phi_0_2;
      end
      else begin
        phi_0_2_offset <= rawData_phi_0_2;
      end
    end

  assign #2 phi_0_2_1 = phi_0_2_offset;

  always @(rawData_lambda_0_0 or rdEnb)
    begin : stimuli_lambda_0_3
      if (rdEnb == 1'b0) begin
        lambda_0_0_offset <= holdData_lambda_0_0;
      end
      else begin
        lambda_0_0_offset <= rawData_lambda_0_0;
      end
    end

  assign #2 lambda_0_0_1 = lambda_0_0_offset;

  always @(rawData_lambda_0_1 or rdEnb)
    begin : stimuli_lambda_0_4
      if (rdEnb == 1'b0) begin
        lambda_0_1_offset <= holdData_lambda_0_1;
      end
      else begin
        lambda_0_1_offset <= rawData_lambda_0_1;
      end
    end

  assign #2 lambda_0_1_1 = lambda_0_1_offset;

  always @(rawData_lambda_0_2 or rdEnb)
    begin : stimuli_lambda_0_5
      if (rdEnb == 1'b0) begin
        lambda_0_2_offset <= holdData_lambda_0_2;
      end
      else begin
        lambda_0_2_offset <= rawData_lambda_0_2;
      end
    end

  assign #2 lambda_0_2_1 = lambda_0_2_offset;

  always @(rawData_opName_1_0 or rdEnb)
    begin : stimuli_opName_1_3
      if (rdEnb == 1'b0) begin
        opName_1_0_offset <= holdData_opName_1_0;
      end
      else begin
        opName_1_0_offset <= rawData_opName_1_0;
      end
    end

  assign #2 opName_1_0_1 = opName_1_0_offset;

  always @(rawData_opName_1_1 or rdEnb)
    begin : stimuli_opName_1_4
      if (rdEnb == 1'b0) begin
        opName_1_1_offset <= holdData_opName_1_1;
      end
      else begin
        opName_1_1_offset <= rawData_opName_1_1;
      end
    end

  assign #2 opName_1_1_1 = opName_1_1_offset;

  always @(rawData_opName_1_2 or rdEnb)
    begin : stimuli_opName_1_5
      if (rdEnb == 1'b0) begin
        opName_1_2_offset <= holdData_opName_1_2;
      end
      else begin
        opName_1_2_offset <= rawData_opName_1_2;
      end
    end

  assign #2 opName_1_2_1 = opName_1_2_offset;

  always @(rawData_theta_1_0 or rdEnb)
    begin : stimuli_theta_1_3
      if (rdEnb == 1'b0) begin
        theta_1_0_offset <= holdData_theta_1_0;
      end
      else begin
        theta_1_0_offset <= rawData_theta_1_0;
      end
    end

  assign #2 theta_1_0_1 = theta_1_0_offset;

  always @(rawData_theta_1_1 or rdEnb)
    begin : stimuli_theta_1_4
      if (rdEnb == 1'b0) begin
        theta_1_1_offset <= holdData_theta_1_1;
      end
      else begin
        theta_1_1_offset <= rawData_theta_1_1;
      end
    end

  assign #2 theta_1_1_1 = theta_1_1_offset;

  always @(rawData_theta_1_2 or rdEnb)
    begin : stimuli_theta_1_5
      if (rdEnb == 1'b0) begin
        theta_1_2_offset <= holdData_theta_1_2;
      end
      else begin
        theta_1_2_offset <= rawData_theta_1_2;
      end
    end

  assign #2 theta_1_2_1 = theta_1_2_offset;

  always @(rawData_phi_1_0 or rdEnb)
    begin : stimuli_phi_1_3
      if (rdEnb == 1'b0) begin
        phi_1_0_offset <= holdData_phi_1_0;
      end
      else begin
        phi_1_0_offset <= rawData_phi_1_0;
      end
    end

  assign #2 phi_1_0_1 = phi_1_0_offset;

  always @(rawData_phi_1_1 or rdEnb)
    begin : stimuli_phi_1_4
      if (rdEnb == 1'b0) begin
        phi_1_1_offset <= holdData_phi_1_1;
      end
      else begin
        phi_1_1_offset <= rawData_phi_1_1;
      end
    end

  assign #2 phi_1_1_1 = phi_1_1_offset;

  always @(rawData_phi_1_2 or rdEnb)
    begin : stimuli_phi_1_5
      if (rdEnb == 1'b0) begin
        phi_1_2_offset <= holdData_phi_1_2;
      end
      else begin
        phi_1_2_offset <= rawData_phi_1_2;
      end
    end

  assign #2 phi_1_2_1 = phi_1_2_offset;

  always @(rawData_lambda_1_0 or rdEnb)
    begin : stimuli_lambda_1_3
      if (rdEnb == 1'b0) begin
        lambda_1_0_offset <= holdData_lambda_1_0;
      end
      else begin
        lambda_1_0_offset <= rawData_lambda_1_0;
      end
    end

  assign #2 lambda_1_0_1 = lambda_1_0_offset;

  always @(rawData_lambda_1_1 or rdEnb)
    begin : stimuli_lambda_1_4
      if (rdEnb == 1'b0) begin
        lambda_1_1_offset <= holdData_lambda_1_1;
      end
      else begin
        lambda_1_1_offset <= rawData_lambda_1_1;
      end
    end

  assign #2 lambda_1_1_1 = lambda_1_1_offset;

  always @(rawData_lambda_1_2 or rdEnb)
    begin : stimuli_lambda_1_5
      if (rdEnb == 1'b0) begin
        lambda_1_2_offset <= holdData_lambda_1_2;
      end
      else begin
        lambda_1_2_offset <= rawData_lambda_1_2;
      end
    end

  assign #2 lambda_1_2_1 = lambda_1_2_offset;

  always @(rawData_initState_0_re_0 or rdEnb)
    begin : stimuli_initState_0_4
      if (rdEnb == 1'b0) begin
        initState_0_re_0_offset <= holdData_initState_0_re_0;
      end
      else begin
        initState_0_re_0_offset <= rawData_initState_0_re_0;
      end
    end

  assign #2 initState_0_re_0_1 = initState_0_re_0_offset;

  always @(rawData_initState_0_re_1 or rdEnb)
    begin : stimuli_initState_0_5
      if (rdEnb == 1'b0) begin
        initState_0_re_1_offset <= holdData_initState_0_re_1;
      end
      else begin
        initState_0_re_1_offset <= rawData_initState_0_re_1;
      end
    end

  assign #2 initState_0_re_1_1 = initState_0_re_1_offset;

  always @(rawData_initState_0_im_0 or rdEnb)
    begin : stimuli_initState_0_6
      if (rdEnb == 1'b0) begin
        initState_0_im_0_offset <= holdData_initState_0_im_0;
      end
      else begin
        initState_0_im_0_offset <= rawData_initState_0_im_0;
      end
    end

  assign #2 initState_0_im_0_1 = initState_0_im_0_offset;

  always @(rawData_initState_0_im_1 or rdEnb)
    begin : stimuli_initState_0_7
      if (rdEnb == 1'b0) begin
        initState_0_im_1_offset <= holdData_initState_0_im_1;
      end
      else begin
        initState_0_im_1_offset <= rawData_initState_0_im_1;
      end
    end

  assign #2 initState_0_im_1_1 = initState_0_im_1_offset;

  always @(rawData_initState_1_re_0 or rdEnb)
    begin : stimuli_initState_1_4
      if (rdEnb == 1'b0) begin
        initState_1_re_0_offset <= holdData_initState_1_re_0;
      end
      else begin
        initState_1_re_0_offset <= rawData_initState_1_re_0;
      end
    end

  assign #2 initState_1_re_0_1 = initState_1_re_0_offset;

  always @(rawData_initState_1_re_1 or rdEnb)
    begin : stimuli_initState_1_5
      if (rdEnb == 1'b0) begin
        initState_1_re_1_offset <= holdData_initState_1_re_1;
      end
      else begin
        initState_1_re_1_offset <= rawData_initState_1_re_1;
      end
    end

  assign #2 initState_1_re_1_1 = initState_1_re_1_offset;

  always @(rawData_initState_1_im_0 or rdEnb)
    begin : stimuli_initState_1_6
      if (rdEnb == 1'b0) begin
        initState_1_im_0_offset <= holdData_initState_1_im_0;
      end
      else begin
        initState_1_im_0_offset <= rawData_initState_1_im_0;
      end
    end

  assign #2 initState_1_im_0_1 = initState_1_im_0_offset;

  always @(rawData_initState_1_im_1 or rdEnb)
    begin : stimuli_initState_1_7
      if (rdEnb == 1'b0) begin
        initState_1_im_1_offset <= holdData_initState_1_im_1;
      end
      else begin
        initState_1_im_1_offset <= rawData_initState_1_im_1;
      end
    end

  assign #2 initState_1_im_1_1 = initState_1_im_1_offset;

  quantumComputer_twoQubit_fixpt u_quantumComputer_twoQubit_fixpt (.opName_0_0(opName_0_0_1),  // uint16
                                                                   .opName_0_1(opName_0_1_1),  // uint16
                                                                   .opName_0_2(opName_0_2_1),  // uint16
                                                                   .theta_0_0(theta_0_0_1),  // sfix16_En13
                                                                   .theta_0_1(theta_0_1_1),  // sfix16_En13
                                                                   .theta_0_2(theta_0_2_1),  // sfix16_En13
                                                                   .phi_0_0(phi_0_0_1),  // sfix16_En13
                                                                   .phi_0_1(phi_0_1_1),  // sfix16_En13
                                                                   .phi_0_2(phi_0_2_1),  // sfix16_En13
                                                                   .lambda_0_0(lambda_0_0_1),  // sfix16_En13
                                                                   .lambda_0_1(lambda_0_1_1),  // sfix16_En13
                                                                   .lambda_0_2(lambda_0_2_1),  // sfix16_En13
                                                                   .opName_1_0(opName_1_0_1),  // uint16
                                                                   .opName_1_1(opName_1_1_1),  // uint16
                                                                   .opName_1_2(opName_1_2_1),  // uint16
                                                                   .theta_1_0(theta_1_0_1),  // sfix16_En13
                                                                   .theta_1_1(theta_1_1_1),  // sfix16_En13
                                                                   .theta_1_2(theta_1_2_1),  // sfix16_En13
                                                                   .phi_1_0(phi_1_0_1),  // sfix16_En13
                                                                   .phi_1_1(phi_1_1_1),  // sfix16_En13
                                                                   .phi_1_2(phi_1_2_1),  // sfix16_En13
                                                                   .lambda_1_0(lambda_1_0_1),  // sfix16_En13
                                                                   .lambda_1_1(lambda_1_1_1),  // sfix16_En13
                                                                   .lambda_1_2(lambda_1_2_1),  // sfix16_En13
                                                                   .initState_0_re_0(initState_0_re_0_1),  // sfix16_En15
                                                                   .initState_0_re_1(initState_0_re_1_1),  // sfix16_En15
                                                                   .initState_0_im_0(initState_0_im_0_1),  // sfix16_En15
                                                                   .initState_0_im_1(initState_0_im_1_1),  // sfix16_En15
                                                                   .initState_1_re_0(initState_1_re_0_1),  // sfix16_En15
                                                                   .initState_1_re_1(initState_1_re_1_1),  // sfix16_En15
                                                                   .initState_1_im_0(initState_1_im_0_1),  // sfix16_En15
                                                                   .initState_1_im_1(initState_1_im_1_1),  // sfix16_En15
                                                                   .computerState_re_0(computerState_re_0),  // sfix16_En15
                                                                   .computerState_re_1(computerState_re_1),  // sfix16_En15
                                                                   .computerState_re_2(computerState_re_2),  // sfix16_En15
                                                                   .computerState_re_3(computerState_re_3),  // sfix16_En15
                                                                   .computerState_im_0(computerState_im_0),  // sfix16_En15
                                                                   .computerState_im_1(computerState_im_1),  // sfix16_En15
                                                                   .computerState_im_2(computerState_im_2),  // sfix16_En15
                                                                   .computerState_im_3(computerState_im_3),  // sfix16_En15
                                                                   .probFinal_0(probFinal_0),  // ufix16_En16
                                                                   .probFinal_1(probFinal_1),  // ufix16_En16
                                                                   .probFinal_2(probFinal_2),  // ufix16_En16
                                                                   .probFinal_3(probFinal_3),  // ufix16_En16
                                                                   .probQubit0_0(probQubit0_0),  // ufix16_En16
                                                                   .probQubit0_1(probQubit0_1),  // ufix16_En16
                                                                   .probQubit1_0(probQubit1_0),  // ufix16_En16
                                                                   .probQubit1_1(probQubit1_1)  // ufix16_En16
                                                                   );

  // Data source for computerState_re_0_re_0_expected
  assign computerState_re_0_re_0_expected_1 = 16'sb0100111001101101;



  assign computerState_re_0_ref = computerState_re_0_re_0_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_re_0_checker
      if (reset == 1'b1) begin
        computerState_re_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_re_0 !== computerState_re_0_ref) begin
          computerState_re_0_testFailure <= 1'b1;
          $display("ERROR in computerState_re_0 at time %t : Expected '%h' Actual '%h'", $time, computerState_re_0_ref, computerState_re_0);
        end
      end
    end

  // Data source for computerState_re_0_re_1_expected
  assign computerState_re_0_re_1_expected_1 = 16'sb0000100001110000;



  assign computerState_re_1_ref = computerState_re_0_re_1_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_re_1_checker
      if (reset == 1'b1) begin
        computerState_re_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_re_1 !== computerState_re_1_ref) begin
          computerState_re_1_testFailure <= 1'b1;
          $display("ERROR in computerState_re_1 at time %t : Expected '%h' Actual '%h'", $time, computerState_re_1_ref, computerState_re_1);
        end
      end
    end

  // Data source for computerState_re_0_re_2_expected
  assign computerState_re_0_re_2_expected_1 = 16'sb1100001000100101;



  assign computerState_re_2_ref = computerState_re_0_re_2_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_re_2_checker
      if (reset == 1'b1) begin
        computerState_re_2_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_re_2 !== computerState_re_2_ref) begin
          computerState_re_2_testFailure <= 1'b1;
          $display("ERROR in computerState_re_2 at time %t : Expected '%h' Actual '%h'", $time, computerState_re_2_ref, computerState_re_2);
        end
      end
    end

  // Data source for computerState_re_0_re_3_expected
  assign computerState_re_0_re_3_expected_1 = 16'sb1111010010011010;



  assign computerState_re_3_ref = computerState_re_0_re_3_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_re_3_checker
      if (reset == 1'b1) begin
        computerState_re_3_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_re_3 !== computerState_re_3_ref) begin
          computerState_re_3_testFailure <= 1'b1;
          $display("ERROR in computerState_re_3 at time %t : Expected '%h' Actual '%h'", $time, computerState_re_3_ref, computerState_re_3);
        end
      end
    end

  // Data source for computerState_re_0_im_0_expected
  assign computerState_re_0_im_0_expected_1 = 16'sb0010101001001101;



  assign computerState_im_0_ref = computerState_re_0_im_0_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_im_0_checker
      if (reset == 1'b1) begin
        computerState_im_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_im_0 !== computerState_im_0_ref) begin
          computerState_im_0_testFailure <= 1'b1;
          $display("ERROR in computerState_im_0 at time %t : Expected '%h' Actual '%h'", $time, computerState_im_0_ref, computerState_im_0);
        end
      end
    end

  // Data source for computerState_re_0_im_1_expected
  assign computerState_re_0_im_1_expected_1 = 16'sb1101101000000100;



  assign computerState_im_1_ref = computerState_re_0_im_1_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_im_1_checker
      if (reset == 1'b1) begin
        computerState_im_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_im_1 !== computerState_im_1_ref) begin
          computerState_im_1_testFailure <= 1'b1;
          $display("ERROR in computerState_im_1 at time %t : Expected '%h' Actual '%h'", $time, computerState_im_1_ref, computerState_im_1);
        end
      end
    end

  // Data source for computerState_re_0_im_2_expected
  assign computerState_re_0_im_2_expected_1 = 16'sb1101001101011010;



  assign computerState_im_2_ref = computerState_re_0_im_2_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_im_2_checker
      if (reset == 1'b1) begin
        computerState_im_2_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_im_2 !== computerState_im_2_ref) begin
          computerState_im_2_testFailure <= 1'b1;
          $display("ERROR in computerState_im_2 at time %t : Expected '%h' Actual '%h'", $time, computerState_im_2_ref, computerState_im_2);
        end
      end
    end

  // Data source for computerState_re_0_im_3_expected
  assign computerState_re_0_im_3_expected_1 = 16'sb0001111101001101;



  assign computerState_im_3_ref = computerState_re_0_im_3_expected_1;

  always @(posedge clk or posedge reset)
    begin : computerState_im_3_checker
      if (reset == 1'b1) begin
        computerState_im_3_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && computerState_im_3 !== computerState_im_3_ref) begin
          computerState_im_3_testFailure <= 1'b1;
          $display("ERROR in computerState_im_3 at time %t : Expected '%h' Actual '%h'", $time, computerState_im_3_ref, computerState_im_3);
        end
      end
    end

  // Data source for probFinal_0_0_expected
  assign probFinal_0_0_expected_1 = 16'b0111110000001111;



  assign probFinal_0_ref = probFinal_0_0_expected_1;

  always @(posedge clk or posedge reset)
    begin : probFinal_0_checker
      if (reset == 1'b1) begin
        probFinal_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probFinal_0 !== probFinal_0_ref) begin
          probFinal_0_testFailure <= 1'b1;
          $display("ERROR in probFinal_0 at time %t : Expected '%h' Actual '%h'", $time, probFinal_0_ref, probFinal_0);
        end
      end
    end

  // Data source for probFinal_0_1_expected
  assign probFinal_0_1_expected_1 = 16'b0001011110101001;



  assign probFinal_1_ref = probFinal_0_1_expected_1;

  always @(posedge clk or posedge reset)
    begin : probFinal_1_checker
      if (reset == 1'b1) begin
        probFinal_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probFinal_1 !== probFinal_1_ref) begin
          probFinal_1_testFailure <= 1'b1;
          $display("ERROR in probFinal_1 at time %t : Expected '%h' Actual '%h'", $time, probFinal_1_ref, probFinal_1);
        end
      end
    end

  // Data source for probFinal_0_2_expected
  assign probFinal_0_2_expected_1 = 16'b0101101011101110;



  assign probFinal_2_ref = probFinal_0_2_expected_1;

  always @(posedge clk or posedge reset)
    begin : probFinal_2_checker
      if (reset == 1'b1) begin
        probFinal_2_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probFinal_2 !== probFinal_2_ref) begin
          probFinal_2_testFailure <= 1'b1;
          $display("ERROR in probFinal_2 at time %t : Expected '%h' Actual '%h'", $time, probFinal_2_ref, probFinal_2);
        end
      end
    end

  // Data source for probFinal_0_3_expected
  assign probFinal_0_3_expected_1 = 16'b0001000101010101;



  assign probFinal_3_ref = probFinal_0_3_expected_1;

  always @(posedge clk or posedge reset)
    begin : probFinal_3_checker
      if (reset == 1'b1) begin
        probFinal_3_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probFinal_3 !== probFinal_3_ref) begin
          probFinal_3_testFailure <= 1'b1;
          $display("ERROR in probFinal_3 at time %t : Expected '%h' Actual '%h'", $time, probFinal_3_ref, probFinal_3);
        end
      end
    end

  // Data source for probQubit0_0_0_expected
  assign probQubit0_0_0_expected_1 = 16'b1001001110111000;



  assign probQubit0_0_ref = probQubit0_0_0_expected_1;

  always @(posedge clk or posedge reset)
    begin : probQubit0_0_checker
      if (reset == 1'b1) begin
        probQubit0_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probQubit0_0 !== probQubit0_0_ref) begin
          probQubit0_0_testFailure <= 1'b1;
          $display("ERROR in probQubit0_0 at time %t : Expected '%h' Actual '%h'", $time, probQubit0_0_ref, probQubit0_0);
        end
      end
    end

  // Data source for probQubit0_0_1_expected
  assign probQubit0_0_1_expected_1 = 16'b0110110001000011;



  assign probQubit0_1_ref = probQubit0_0_1_expected_1;

  always @(posedge clk or posedge reset)
    begin : probQubit0_1_checker
      if (reset == 1'b1) begin
        probQubit0_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probQubit0_1 !== probQubit0_1_ref) begin
          probQubit0_1_testFailure <= 1'b1;
          $display("ERROR in probQubit0_1 at time %t : Expected '%h' Actual '%h'", $time, probQubit0_1_ref, probQubit0_1);
        end
      end
    end

  // Data source for probQubit1_0_0_expected
  assign probQubit1_0_0_expected_1 = 16'b1101011011111101;



  assign probQubit1_0_ref = probQubit1_0_0_expected_1;

  always @(posedge clk or posedge reset)
    begin : probQubit1_0_checker
      if (reset == 1'b1) begin
        probQubit1_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probQubit1_0 !== probQubit1_0_ref) begin
          probQubit1_0_testFailure <= 1'b1;
          $display("ERROR in probQubit1_0 at time %t : Expected '%h' Actual '%h'", $time, probQubit1_0_ref, probQubit1_0);
        end
      end
    end

  // Data source for probQubit1_0_1_expected
  assign probQubit1_0_1_expected_1 = 16'b0010100011111110;



  assign probQubit1_1_ref = probQubit1_0_1_expected_1;

  always @(posedge clk or posedge reset)
    begin : probQubit1_1_checker
      if (reset == 1'b1) begin
        probQubit1_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && probQubit1_1 !== probQubit1_1_ref) begin
          probQubit1_1_testFailure <= 1'b1;
          $display("ERROR in probQubit1_1 at time %t : Expected '%h' Actual '%h'", $time, probQubit1_1_ref, probQubit1_1);
        end
      end
    end

  assign testFailure = probQubit1_1_testFailure | (probQubit1_0_testFailure | (probQubit0_1_testFailure | (probQubit0_0_testFailure | (probFinal_3_testFailure | (probFinal_2_testFailure | (probFinal_1_testFailure | (probFinal_0_testFailure | (computerState_im_3_testFailure | (computerState_im_2_testFailure | (computerState_im_1_testFailure | (computerState_im_0_testFailure | (computerState_re_3_testFailure | (computerState_re_2_testFailure | (computerState_re_0_testFailure | computerState_re_1_testFailure))))))))))))));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // quantumComputer_twoQubit_fixpt_tb

